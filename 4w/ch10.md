# CH10, 일급 함수

## 암묵적 인자를 제거 -> 코드의 냄세 제거

- 비슷하게 생긴 형태의 함수를 공용으로 변경하기
- 함수 이름에 있는 암묵적 인자를, 일급 값(firts-class value)으로 변경하여 다른 값처럼 사용하도록 수정
- 일급값
  - 해당 언어에서 다른 값처럼 사용이 가능한 값
  - 숫자, 문자열 등은 일급 값이나 연산자, 함수명 등은 일급 값이 아니다

\*\* 번역을 이따구로 굳이 해야하나? 직접 사용 값, 직접 접근 값 이런게 더 좋지 않을까? 영어로 first class 이긴 하지만 이런건 좀 센스있게 설명이 붙으면 더 좋을 것 같다!<br>
\*\* 근데 이건 번역 문제라기 보다는 애초에 이름을 first class로 지은게 문제인듯....

```js
function setPriceByName(cart, name, price) {
  // 필드 명으로 가격을 바꾸는 함수
}

function setQuantityByName(cart, name, price) {
  // 필드 명으로 수량을 바꾸는 함수
}

// 위와 같이 함수 이름에 암묵적 인자가 있는 함수들을 아래와 같이 일급 값을 사용하는 함수로 변경
function setFieldByName(cart, name, field, value) {
  // 전달 된 필드 값을 바탕으로 해당 값을 변경하는 함수
}

const new_cart = setPriceByName(cart, "shoe", 13);
const new_cart = setQuantityByName(cart, "shoe", 3);

// 위의 내용을 아래와 같이 변경 가능
const new_cart = setFieldByName(cart, "shoe", "price", 13);
const new_cart = setQuantityByName(cart, "shoe", "quantity", 3);
```

## 필드명을 문자열로 사용하면 버그가 생기지 않을까?

- 자바스크립트는 런타임(인터프리터) 언어므로 실행 시점에서 문제를 처리 해줘야 함
- 타입스크립트 Enum 또는 인터페이스 등으로 해결은 가능

```js
const vaildItemField = ["price", "quantity", "shipping", "tax"];

function setFieldByName(cart, name, field, value) {
  // 이런 구문을 통해 해결
  if (!vaildItemField.includes(field)) throw err;

  // 필드 설정 코드
}
```

### 연습문제 1

```js
function multipleByFactor(num, factor) {
  return num * factor;
}
```

### 연습문제 2

```js
function incrementFieldByName(cart, field, name) {
  const item = cart[name];
  const fieldValue = item[field];
  const newFieldValue = fieldValue + 1;
  // 나머지 코드
}
```

### 연습문제 3

```js
function incrementFieldByName(cart, field, name) {
  const vaildFieldName = ["size", "quantity"];
  if (!vaildFieldName.includes(field)) throw err;

  const item = cart[name];
  const fieldValue = item[field];
  const newFieldValue = fieldValue + 1;
  // 나머지 코드
}
```

## 데이터 지향

- 책의 내용 : 이벤트와 엔티티 대한 사실을 일반적인 데이터 구조를 사용하는 것
- 이게 뭔소리인가 싶어서 시작 된 여정의 요약
- 찾다보니 해당 책의 저자가 직접 올린 팟캐스트 내용 발견
  - https://ericnormand.me/podcast/what-is-data-orientation

\*\* 저자의 핵심 코멘트

```
Data orientation is basically saying, "Let's leave it as data. It came in as data, it's going to go out as data. Let's treat it like data the whole way through."

데이터 지향성은 기본적으로 "데이터로 남겨두자. 데이터로 들어온 것이니, 데이터로 나갈 것이다. 처음부터 끝까지 데이터로 취급하자"는 것입니다
```

### 팟캐스트 내용 요약 && 내 생각 및 추가 조사 내용 정리

- 최하 단계의 데이터에 대한 해석을 미리 정해서 인터페이스로만 접근이 가능하도록 하지 말고, 다양한 해석이 가능한 일반적인 형태의 데이터로 남겨두고 사용하라는 이야기로 파악
- 즉, 데이터는 기본 형태의 데이터로 두고 실제 개발은 위에 인터페이스를 잘 쌓아서 사용하라는 뜻으로 이해함
- 데이터는 데이터 자체로 의미를 가지지 않으며, 오히려 해석이 들어가는 순간 데이터가 가지는 순수한 의미에서 벗어나 중립성을 잃기 때문
- 그리고 기본적인 데이터 형태로 남아 있을 경우, 다양한 방법을 통해서 편리하게 이용이 가능 (ex. 알고리즘 적용, 해시맵 사용 등등)
- 다만 해당 개념은 은닉화(캡슐레이션)가 기본이 되는 OOP 와는 상충되는 개념
- 저자는 데이터를 숨길 필요가 있다면 은닉화를 해서 인터페이스를 만들고, 숨길 필요가 없다면 데이터 자체로 남기는 것이 좋다는 의견
- 실제 컴퓨팅 성능 측면에서 OOP 대비 데이터지향 프로그래밍이 성능이 더 뛰어난 결과가 있음
  - 단, 가독성 및 유지 보수성이 떨어져서 OOP가 더 많이 사용되는 추세
  - 참고 자료 : https://yozm.wishket.com/magazine/detail/2157/

<br><br>

### 아래는 저자의 팟캐스트 내용 파파고 번역본

데이터 지향이란 무엇인가요? 이 에피소드가 끝날 때쯤, 여러분은 데이터 지향에 대해 이야기할 때 기능 프로그래밍에서 우리가 의미하는 바를 더 잘 알 수 있을 것입니다. 기능 언어에서 매우 일반적인 아이디어입니다.

안녕하세요, 제 이름은 에릭 노만드이고 기능적 프로그래밍으로 사람들이 번창할 수 있도록 도와줍니다.

데이터 지향이 정말 빠르네요, 데이터로 프로그래밍을 하고 있습니다. 그 이상으로 좀 더 깊이 들어가 보겠습니다.

데이터란 무엇인가요? 기본부터 시작하겠습니다. 이제 사전에서 찾아보면 사건에 대한 사실이라고 나옵니다. 어떤 일이 일어나고, 사건이 일어나고, 이제 여러분은 그것에 대한 사실을 알게 됩니다. 온도를 측정했을 수도 있고, 그것은 측정했던 사건에 대한 사실입니다. 온도계가 알려준 것은 이것입니다. 온도는 80도입니다.

그것들은 사건에 대한 사실이고, 그것은 매우 명확한 정의입니다. 우리가 데이터 방향을 설정할 때, 우리는 데이터로 프로그래밍을 합니다. 우리의 많은 코드는 데이터 변환이 됩니다. 우리는 하나의 소스로부터 데이터를 얻고 그것을 처리하고 있습니다. 우리는 그것을 저장하고, 전송하고, 우리는 이 데이터로 무엇인가를 하고 있습니다.

제가 데이터 오리엔테이션을 좋아하는 이유 중 하나는 보통 정보 시스템을 만들고 있기 때문입니다. 특히 백엔드에서는 정보를 받아들이고 HTTP 요청을 받고 있습니다. 트랜잭션이나 다른 API 호출을 받거나 센서를 읽고 있습니다. 뭔가를 하고 있고, 정보를 받아들이고 있고 그것을 가지고 뭔가를 하고 있습니다.

데이터 지향성은 기본적으로 "데이터로 남겨두자. 데이터로 들어온 것이다, 데이터로 나갈 것이다. 전체를 데이터처럼 취급하자"는 것입니다

데이터는 이것에 좋은 몇 가지 흥미로운 특성을 가지고 있습니다. 하나는 그것이 구조를 가지고 있다는 것입니다. 우리는 컴퓨터 과학자들이 메모리에 저장하고 사용하기에 효율적인 데이터의 다른 구조를 발견했습니다.

또한 인체공학적입니다. 우리는 그것들을 사용하는 알고리즘을 고안했습니다. 그것들은 프로그래머에게 편리합니다. 배열, 해시 맵, 숫자, 문자열 등 우리에게 익숙한 것들을 이야기합니다. 이것들은 단지 데이터일 뿐입니다.

구조를 만들 수도 있고, 그런 것들의 구조에 의존할 수도 있습니다. 데이터가 들어오고, 특정한 속성들이 있습니다. 그런 속성들은 이름과 값을 가질 수도 있습니다. 이런 값들을 속성 이름으로 검색할 것이기 때문에 어쩌면 이것이 해시 맵을 사용하기에 좋은 후보가 될 수도 있다고 생각하는 것은 자연스러운 일입니다.

그게 구조적인 부분입니다. 일종의 플러스 마이너스, 더블 엣지 검은 데이터가 해석을 필요로 한다는 것입니다. 그 자체로 의미가 있는 것은 아닙니다. 제가 숫자 5라고 말하면 제가 단위를 달아도 무슨 뜻인지 전혀 모르실 겁니다. 5파운드, 아직도 무슨 뜻인지 모르실 겁니다.

사용하기 위해서는 맥락이 필요해요. 그 맥락이 데이터에 포함되어 있을 수도 있고, 소프트웨어나 통역사의 관점에서 볼 수도 있어요. 정말 해석이 필요해요. 목적이 있어야 해요. 제가 왜 이걸 읽고 있는 걸까요? 그로부터 무엇을 배울 수 있을까요? 그로부터 어떤 결정을 내릴 수 있을까요?

그 모든 것들은 그런 것들이 없으면 데이터가 아무런 의미가 없다는 것을 의미합니다

데이터란 무엇인가요? 기본부터 시작하겠습니다. 이제 사전에서 찾아보면 사건에 대한 사실이라고 나옵니다. 어떤 일이 일어나고, 사건이 일어나고, 이제 여러분은 그것에 대한 사실을 알게 됩니다. 온도를 측정했을 수도 있고, 그것은 측정했던 사건에 대한 사실입니다. 온도계가 알려준 것은 이것입니다. 온도는 80도입니다.

그것들은 사건에 대한 사실이고, 그것은 매우 명확한 정의입니다. 우리가 데이터 방향을 설정할 때, 우리는 데이터로 프로그래밍을 합니다. 우리의 많은 코드는 데이터 변환이 됩니다. 우리는 하나의 소스로부터 데이터를 얻고 그것을 처리하고 있습니다. 우리는 그것을 저장하고, 전송하고, 우리는 이 데이터로 무엇인가를 하고 있습니다.

제가 데이터 오리엔테이션을 좋아하는 이유 중 하나는 보통 정보 시스템을 만들고 있기 때문입니다. 특히 백엔드에서는 정보를 받아들이고 HTTP 요청을 받고 있습니다. 트랜잭션이나 다른 API 호출을 받거나 센서를 읽고 있습니다. 뭔가를 하고 있고, 정보를 받아들이고 있고 그것을 가지고 뭔가를 하고 있습니다.

데이터 지향성은 기본적으로 "데이터로 남겨두자. 데이터로 들어온 것이다, 데이터로 나갈 것이다. 전체를 데이터처럼 취급하자"는 것입니다

데이터는 이것에 좋은 몇 가지 흥미로운 특성을 가지고 있습니다. 하나는 그것이 구조를 가지고 있다는 것입니다. 우리는 컴퓨터 과학자들이 메모리에 저장하고 사용하기에 효율적인 데이터의 다른 구조를 발견했습니다.

또한 인체공학적입니다. 우리는 그것들을 사용하는 알고리즘을 고안했습니다. 그것들은 프로그래머에게 편리합니다. 배열, 해시 맵, 숫자, 문자열 등 우리에게 익숙한 것들을 이야기합니다. 이것들은 단지 데이터일 뿐입니다.

구조를 만들 수도 있고, 그런 것들의 구조에 의존할 수도 있습니다. 데이터가 들어오고, 특정한 속성들이 있습니다. 그런 속성들은 이름과 값을 가질 수도 있습니다. 이런 값들을 속성 이름으로 검색할 것이기 때문에 어쩌면 이것이 해시 맵을 사용하기에 좋은 후보가 될 수도 있다고 생각하는 것은 자연스러운 일입니다.

그게 구조적인 부분입니다. 일종의 플러스 마이너스, 더블 엣지 검은 데이터가 해석을 필요로 한다는 것입니다. 그 자체로 의미가 있는 것은 아닙니다. 제가 숫자 5라고 말하면 제가 단위를 달아도 무슨 뜻인지 전혀 모르실 겁니다. 5파운드, 아직도 무슨 뜻인지 모르실 겁니다.

사용하기 위해서는 맥락이 필요해요. 그 맥락이 데이터에 포함되어 있을 수도 있고, 소프트웨어나 통역사의 관점에서 볼 수도 있어요. 정말 해석이 필요해요. 목적이 있어야 해요. 제가 왜 이걸 읽고 있는 걸까요? 그로부터 무엇을 배울 수 있을까요? 그로부터 어떤 결정을 내릴 수 있을까요?

그 모든 것들은 그런 것들이 없다면 데이터 자체가 아무런 의미가 없다는 것을 의미합니다. 예를 들어, 저는 이것이 바보 같은 짓이라는 것을 알지만 저는 데이터를 정말 오래된 전통으로 봅니다. 그것은 우리가 가지고 있는 가장 초기의 기록 보관소로 거슬러 올라갑니다.

글이 발명되기 전에, 여러분은 석판 같은 것이나 점토판에 여러분이 어떤 사람과 거래하고 있던 소의 수를 표시할 수 있었습니다. 여러분은 숫자를 세고 있고, 여러분은 기록을 유지하고 있습니다. 각각의 작은 표시들은 사건에 관한 사실입니다.

숨길 필요가 있다면, 지금 하고 있는 일은 그 인터페이스에 다른 인터프리터를 굽는 것입니다. 이것은 클래스를 점점 더 크게 만들 것입니다. 왜냐하면 이것이 필요한 방법이 필요하기 때문입니다. 이것이 필요한 방법이 필요할 것입니다.

아니면 동일한 데이터에 서로 다른 인터페이스를 갖는 시스템을 가질 수도 있지만 그 사이에서 데이터를 어떻게 얻습니까? 정말 어렵습니다.

우리는 데이터 지향성에서 숨기지 않고 그냥 노출시키는 것을 선호합니다. 우리는 데이터 지향성을 실행하고 싶은 어떤 해석자든, 해석하고 싶은 어떤 해석자든 그들이 해야 할 일이 무엇이든 하도록 내버려 둘 것입니다. 그것이 데이터 지향성입니다.

좋습니다. 요약하겠습니다. 데이터 방향은 데이터로 프로그래밍하는 것입니다. 숨김이 없습니다. 데이터는 사건에 대한 사실입니다. 데이터 지향 프로그래밍, 당신은 많은 데이터 변환을 하는 경향이 있습니다. 당신의 시스템은 데이터를 입력, 저장, 전송, 처리하는 것입니다. 그것이 바로 그것이 하는 일입니다. 당신이 하고 있는 모든 것은... 전부가 아니라 대부분의 당신이 하고 있는 것들 중 하나입니다.

데이터에는 구조가 있습니다. 데이터를 사용하는 일반적인 이해 방법이 필요하기 때문에 이러한 구조가 필요합니다. 제가 의미하는 것은 문자열의 구조를 알고 있다는 것입니다. 인덱스로 각 문자에 액세스할 수 있으며 문자는 일종의 유니코드가 될 것입니다. 그 중 두 개를 추가할 수 있습니다. 우리가 이해하는 구조가 있습니다.

그렇다면 해석이 필요합니다. 양날의 칼이지요. 필요하지만 같은 데이터를 해석하는 다른 방법을 허용합니다.

대박. 이 에피소드가 마음에 드신다면 구독을 해주셔야죠. 바로 여기 있어요. 여기 제 노트가 있어요. 이 중 두 개만 더 녹음할 준비가 되어 있고 이 다음에 바로 내려올 거예요. 구독을 해주시면 받으실 수 있을 거예요.

원하신다면 lispcast.com/podcast 에 접속해 보세요. 구독 링크와 소셜 미디어를 통해 저에게 연락할 수 있습니다. 저는 토론에 참여하는 것을 좋아합니다. 이런 많은 주제들은 제가 어떤 말을 했기 때문에 사람들이 가진 질문에서 나왔는데, 그들은 그것을 이해하지 못했습니다. 제가 혼란스러워하고 있었습니다. 더 많은 설명이 필요해서 이런 것입니다.

저도 그냥 토론에 참여하는 게 좋을 것 같아요. 저와 의견이 다를 수도 있어요. 데이터 지향성이 무엇을 의미하는지에 대해 다른 생각을 하고 계실 수도 있어요.

lispcast.com/podcast, 에서도 모든 오래된 팟캐스트, 이전 팟캐스트, 오디오, 비디오 및 텍스트 녹취록이 포함된 에피소드를 찾을 수 있으므로 원하는 대로 소비할 수 있습니다.

알겠습니다. 지금까지 기능성 프로그래밍에 대한 생각을 정리했습니다. 에릭 노먼입니다. 들어주시고 응원해주셔서 감사합니다.

\*\* 정적 vs 동적 (컴파일 vs 인터프리터), 이걸로 싸울 시간에 품질을 위해 숙면을 취하라 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ

<br><br>

## 반복문 처리하기

- 반복문을 콜백 리팩터링으로 수정
- 반복문을 함수화 -> 반복문을 제외한 함수를 인자로 받아서 고차 함수로 만들어서 처리

```js
function cookAndEatFoods() {
  for (let i = 0; i < foods.length; i++) {
    const food = foods[i];
    cook(food);
    eat(food);
  }
}

// 위의 코드를
function forEach(arr, foo) {
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    foo(item);
  }
}

function cookAndEat(food) {
  cook(food);
  eat(food);
}

forEach(foods, cookAndEat);
```

\*\* foo는 일종의 홍길동 같은 거라네요... 이번에 처음 알게 됨

## 익명함수 전달하기

### 함수 정의의 3가지 방법

- 전역 정의(함수 선언)
  - function 사용 -> 호이스팅 적용
- 지역 정의(변수 사용)
  - 변수에 함수 담기
- 인라인 정의(익명 함수)
  - 사용하는 곳에서 직접 정의

```js
try {
  saveUserData(user);
} catch (err) {
  logToSnapErrors(err);
}

// 위의 코드를
function withLogging(foo) {
  try {
    foo();
  } catch (err) {
    logToSnapErrors(err);
  }
}

withLogging(function () {
  saveUserData(user);
});
```

### 익명함수 차이 확인하기

```js
withLogging(function () {
  saveUserData(user);
});

withLogging(() => saveUserData(user));

// 아래의 케이스를 보면 금방 확인이 가능!
withLogging(function () {
  console.log("일반 함수", this);
});

withLogging(() => console.log("화살표 함수", this));
```

1. this 바인딩 차이(일반 O / 화살표 X)
2. 생성자 함수로 사용 여부(일반 O / 화살표 X, prototype 프로퍼티 유무)
3. arguments 인자 사용 가능 여부(일반 O / 화살표 X)
